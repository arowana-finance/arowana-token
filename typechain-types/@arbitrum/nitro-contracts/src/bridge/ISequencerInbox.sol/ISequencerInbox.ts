/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  EventFragment,
  AddressLike,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedLogDescription,
  TypedListener,
  TypedContractMethod,
} from "../../../../../common.js";

export type BufferConfigStruct = {
  threshold: BigNumberish;
  max: BigNumberish;
  replenishRateInBasis: BigNumberish;
};

export type BufferConfigStructOutput = [
  threshold: bigint,
  max: bigint,
  replenishRateInBasis: bigint,
] & { threshold: bigint; max: bigint; replenishRateInBasis: bigint };

export type DelayProofStruct = {
  beforeDelayedAcc: BytesLike;
  delayedMessage: Messages.MessageStruct;
};

export type DelayProofStructOutput = [
  beforeDelayedAcc: string,
  delayedMessage: Messages.MessageStructOutput,
] & { beforeDelayedAcc: string; delayedMessage: Messages.MessageStructOutput };

export declare namespace ISequencerInbox {
  export type MaxTimeVariationStruct = {
    delayBlocks: BigNumberish;
    futureBlocks: BigNumberish;
    delaySeconds: BigNumberish;
    futureSeconds: BigNumberish;
  };

  export type MaxTimeVariationStructOutput = [
    delayBlocks: bigint,
    futureBlocks: bigint,
    delaySeconds: bigint,
    futureSeconds: bigint,
  ] & {
    delayBlocks: bigint;
    futureBlocks: bigint;
    delaySeconds: bigint;
    futureSeconds: bigint;
  };
}

export declare namespace IBridge {
  export type TimeBoundsStruct = {
    minTimestamp: BigNumberish;
    maxTimestamp: BigNumberish;
    minBlockNumber: BigNumberish;
    maxBlockNumber: BigNumberish;
  };

  export type TimeBoundsStructOutput = [
    minTimestamp: bigint,
    maxTimestamp: bigint,
    minBlockNumber: bigint,
    maxBlockNumber: bigint,
  ] & {
    minTimestamp: bigint;
    maxTimestamp: bigint;
    minBlockNumber: bigint;
    maxBlockNumber: bigint;
  };
}

export declare namespace Messages {
  export type MessageStruct = {
    kind: BigNumberish;
    sender: AddressLike;
    blockNumber: BigNumberish;
    timestamp: BigNumberish;
    inboxSeqNum: BigNumberish;
    baseFeeL1: BigNumberish;
    messageDataHash: BytesLike;
  };

  export type MessageStructOutput = [
    kind: bigint,
    sender: string,
    blockNumber: bigint,
    timestamp: bigint,
    inboxSeqNum: bigint,
    baseFeeL1: bigint,
    messageDataHash: string,
  ] & {
    kind: bigint;
    sender: string;
    blockNumber: bigint;
    timestamp: bigint;
    inboxSeqNum: bigint;
    baseFeeL1: bigint;
    messageDataHash: string;
  };
}

export interface ISequencerInboxInterface extends Interface {
  getFunction(
    nameOrSignature:
      | "BROTLI_MESSAGE_HEADER_FLAG"
      | "DAS_MESSAGE_HEADER_FLAG"
      | "DATA_AUTHENTICATED_FLAG"
      | "DATA_BLOB_HEADER_FLAG"
      | "HEADER_LENGTH"
      | "TREE_DAS_MESSAGE_HEADER_FLAG"
      | "ZERO_HEAVY_MESSAGE_HEADER_FLAG"
      | "addSequencerL2Batch"
      | "addSequencerL2BatchDelayProof"
      | "addSequencerL2BatchFromBlobs"
      | "addSequencerL2BatchFromBlobsDelayProof"
      | "addSequencerL2BatchFromOrigin(uint256,bytes,uint256,address)"
      | "addSequencerL2BatchFromOrigin(uint256,bytes,uint256,address,uint256,uint256)"
      | "addSequencerL2BatchFromOriginDelayProof"
      | "batchCount"
      | "batchPosterManager"
      | "bridge"
      | "dasKeySetInfo"
      | "feeTokenPricer"
      | "forceInclusion"
      | "forceInclusionDeadline"
      | "getKeysetCreationBlock"
      | "inboxAccs"
      | "initialize"
      | "invalidateKeysetHash"
      | "isBatchPoster"
      | "isDelayBufferable"
      | "isSequencer"
      | "isValidKeysetHash"
      | "maxDataSize"
      | "maxTimeVariation"
      | "removeDelayAfterFork"
      | "rollup"
      | "setBatchPosterManager"
      | "setFeeTokenPricer"
      | "setIsBatchPoster"
      | "setIsSequencer"
      | "setMaxTimeVariation"
      | "setValidKeyset"
      | "totalDelayedMessagesRead"
      | "updateRollupAddress",
  ): FunctionFragment;

  getEvent(
    nameOrSignatureOrTopic:
      | "BatchPosterManagerSet"
      | "BatchPosterSet"
      | "BufferConfigSet"
      | "FeeTokenPricerSet"
      | "InboxMessageDelivered"
      | "InboxMessageDeliveredFromOrigin"
      | "InvalidateKeyset"
      | "MaxTimeVariationSet"
      | "OwnerFunctionCalled"
      | "SequencerBatchData"
      | "SequencerBatchDelivered"
      | "SequencerSet"
      | "SetValidKeyset",
  ): EventFragment;

  encodeFunctionData(
    functionFragment: "BROTLI_MESSAGE_HEADER_FLAG",
    values?: undefined,
  ): string;
  encodeFunctionData(
    functionFragment: "DAS_MESSAGE_HEADER_FLAG",
    values?: undefined,
  ): string;
  encodeFunctionData(
    functionFragment: "DATA_AUTHENTICATED_FLAG",
    values?: undefined,
  ): string;
  encodeFunctionData(
    functionFragment: "DATA_BLOB_HEADER_FLAG",
    values?: undefined,
  ): string;
  encodeFunctionData(
    functionFragment: "HEADER_LENGTH",
    values?: undefined,
  ): string;
  encodeFunctionData(
    functionFragment: "TREE_DAS_MESSAGE_HEADER_FLAG",
    values?: undefined,
  ): string;
  encodeFunctionData(
    functionFragment: "ZERO_HEAVY_MESSAGE_HEADER_FLAG",
    values?: undefined,
  ): string;
  encodeFunctionData(
    functionFragment: "addSequencerL2Batch",
    values: [
      BigNumberish,
      BytesLike,
      BigNumberish,
      AddressLike,
      BigNumberish,
      BigNumberish,
    ],
  ): string;
  encodeFunctionData(
    functionFragment: "addSequencerL2BatchDelayProof",
    values: [
      BigNumberish,
      BytesLike,
      BigNumberish,
      AddressLike,
      BigNumberish,
      BigNumberish,
      DelayProofStruct,
    ],
  ): string;
  encodeFunctionData(
    functionFragment: "addSequencerL2BatchFromBlobs",
    values: [
      BigNumberish,
      BigNumberish,
      AddressLike,
      BigNumberish,
      BigNumberish,
    ],
  ): string;
  encodeFunctionData(
    functionFragment: "addSequencerL2BatchFromBlobsDelayProof",
    values: [
      BigNumberish,
      BigNumberish,
      AddressLike,
      BigNumberish,
      BigNumberish,
      DelayProofStruct,
    ],
  ): string;
  encodeFunctionData(
    functionFragment: "addSequencerL2BatchFromOrigin(uint256,bytes,uint256,address)",
    values: [BigNumberish, BytesLike, BigNumberish, AddressLike],
  ): string;
  encodeFunctionData(
    functionFragment: "addSequencerL2BatchFromOrigin(uint256,bytes,uint256,address,uint256,uint256)",
    values: [
      BigNumberish,
      BytesLike,
      BigNumberish,
      AddressLike,
      BigNumberish,
      BigNumberish,
    ],
  ): string;
  encodeFunctionData(
    functionFragment: "addSequencerL2BatchFromOriginDelayProof",
    values: [
      BigNumberish,
      BytesLike,
      BigNumberish,
      AddressLike,
      BigNumberish,
      BigNumberish,
      DelayProofStruct,
    ],
  ): string;
  encodeFunctionData(
    functionFragment: "batchCount",
    values?: undefined,
  ): string;
  encodeFunctionData(
    functionFragment: "batchPosterManager",
    values?: undefined,
  ): string;
  encodeFunctionData(functionFragment: "bridge", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "dasKeySetInfo",
    values: [BytesLike],
  ): string;
  encodeFunctionData(
    functionFragment: "feeTokenPricer",
    values?: undefined,
  ): string;
  encodeFunctionData(
    functionFragment: "forceInclusion",
    values: [
      BigNumberish,
      BigNumberish,
      [BigNumberish, BigNumberish],
      BigNumberish,
      AddressLike,
      BytesLike,
    ],
  ): string;
  encodeFunctionData(
    functionFragment: "forceInclusionDeadline",
    values: [BigNumberish],
  ): string;
  encodeFunctionData(
    functionFragment: "getKeysetCreationBlock",
    values: [BytesLike],
  ): string;
  encodeFunctionData(
    functionFragment: "inboxAccs",
    values: [BigNumberish],
  ): string;
  encodeFunctionData(
    functionFragment: "initialize",
    values: [
      AddressLike,
      ISequencerInbox.MaxTimeVariationStruct,
      BufferConfigStruct,
      AddressLike,
    ],
  ): string;
  encodeFunctionData(
    functionFragment: "invalidateKeysetHash",
    values: [BytesLike],
  ): string;
  encodeFunctionData(
    functionFragment: "isBatchPoster",
    values: [AddressLike],
  ): string;
  encodeFunctionData(
    functionFragment: "isDelayBufferable",
    values?: undefined,
  ): string;
  encodeFunctionData(
    functionFragment: "isSequencer",
    values: [AddressLike],
  ): string;
  encodeFunctionData(
    functionFragment: "isValidKeysetHash",
    values: [BytesLike],
  ): string;
  encodeFunctionData(
    functionFragment: "maxDataSize",
    values?: undefined,
  ): string;
  encodeFunctionData(
    functionFragment: "maxTimeVariation",
    values?: undefined,
  ): string;
  encodeFunctionData(
    functionFragment: "removeDelayAfterFork",
    values?: undefined,
  ): string;
  encodeFunctionData(functionFragment: "rollup", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "setBatchPosterManager",
    values: [AddressLike],
  ): string;
  encodeFunctionData(
    functionFragment: "setFeeTokenPricer",
    values: [AddressLike],
  ): string;
  encodeFunctionData(
    functionFragment: "setIsBatchPoster",
    values: [AddressLike, boolean],
  ): string;
  encodeFunctionData(
    functionFragment: "setIsSequencer",
    values: [AddressLike, boolean],
  ): string;
  encodeFunctionData(
    functionFragment: "setMaxTimeVariation",
    values: [ISequencerInbox.MaxTimeVariationStruct],
  ): string;
  encodeFunctionData(
    functionFragment: "setValidKeyset",
    values: [BytesLike],
  ): string;
  encodeFunctionData(
    functionFragment: "totalDelayedMessagesRead",
    values?: undefined,
  ): string;
  encodeFunctionData(
    functionFragment: "updateRollupAddress",
    values?: undefined,
  ): string;

  decodeFunctionResult(
    functionFragment: "BROTLI_MESSAGE_HEADER_FLAG",
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: "DAS_MESSAGE_HEADER_FLAG",
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: "DATA_AUTHENTICATED_FLAG",
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: "DATA_BLOB_HEADER_FLAG",
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: "HEADER_LENGTH",
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: "TREE_DAS_MESSAGE_HEADER_FLAG",
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: "ZERO_HEAVY_MESSAGE_HEADER_FLAG",
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: "addSequencerL2Batch",
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: "addSequencerL2BatchDelayProof",
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: "addSequencerL2BatchFromBlobs",
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: "addSequencerL2BatchFromBlobsDelayProof",
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: "addSequencerL2BatchFromOrigin(uint256,bytes,uint256,address)",
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: "addSequencerL2BatchFromOrigin(uint256,bytes,uint256,address,uint256,uint256)",
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: "addSequencerL2BatchFromOriginDelayProof",
    data: BytesLike,
  ): Result;
  decodeFunctionResult(functionFragment: "batchCount", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "batchPosterManager",
    data: BytesLike,
  ): Result;
  decodeFunctionResult(functionFragment: "bridge", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "dasKeySetInfo",
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: "feeTokenPricer",
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: "forceInclusion",
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: "forceInclusionDeadline",
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: "getKeysetCreationBlock",
    data: BytesLike,
  ): Result;
  decodeFunctionResult(functionFragment: "inboxAccs", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "initialize", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "invalidateKeysetHash",
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: "isBatchPoster",
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: "isDelayBufferable",
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: "isSequencer",
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: "isValidKeysetHash",
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: "maxDataSize",
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: "maxTimeVariation",
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: "removeDelayAfterFork",
    data: BytesLike,
  ): Result;
  decodeFunctionResult(functionFragment: "rollup", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setBatchPosterManager",
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: "setFeeTokenPricer",
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: "setIsBatchPoster",
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: "setIsSequencer",
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: "setMaxTimeVariation",
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: "setValidKeyset",
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: "totalDelayedMessagesRead",
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateRollupAddress",
    data: BytesLike,
  ): Result;
}

export namespace BatchPosterManagerSetEvent {
  export type InputTuple = [newBatchPosterManager: AddressLike];
  export type OutputTuple = [newBatchPosterManager: string];
  export interface OutputObject {
    newBatchPosterManager: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace BatchPosterSetEvent {
  export type InputTuple = [batchPoster: AddressLike, isBatchPoster: boolean];
  export type OutputTuple = [batchPoster: string, isBatchPoster: boolean];
  export interface OutputObject {
    batchPoster: string;
    isBatchPoster: boolean;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace BufferConfigSetEvent {
  export type InputTuple = [bufferConfig: BufferConfigStruct];
  export type OutputTuple = [bufferConfig: BufferConfigStructOutput];
  export interface OutputObject {
    bufferConfig: BufferConfigStructOutput;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FeeTokenPricerSetEvent {
  export type InputTuple = [feeTokenPricer: AddressLike];
  export type OutputTuple = [feeTokenPricer: string];
  export interface OutputObject {
    feeTokenPricer: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace InboxMessageDeliveredEvent {
  export type InputTuple = [messageNum: BigNumberish, data: BytesLike];
  export type OutputTuple = [messageNum: bigint, data: string];
  export interface OutputObject {
    messageNum: bigint;
    data: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace InboxMessageDeliveredFromOriginEvent {
  export type InputTuple = [messageNum: BigNumberish];
  export type OutputTuple = [messageNum: bigint];
  export interface OutputObject {
    messageNum: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace InvalidateKeysetEvent {
  export type InputTuple = [keysetHash: BytesLike];
  export type OutputTuple = [keysetHash: string];
  export interface OutputObject {
    keysetHash: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace MaxTimeVariationSetEvent {
  export type InputTuple = [
    maxTimeVariation: ISequencerInbox.MaxTimeVariationStruct,
  ];
  export type OutputTuple = [
    maxTimeVariation: ISequencerInbox.MaxTimeVariationStructOutput,
  ];
  export interface OutputObject {
    maxTimeVariation: ISequencerInbox.MaxTimeVariationStructOutput;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace OwnerFunctionCalledEvent {
  export type InputTuple = [id: BigNumberish];
  export type OutputTuple = [id: bigint];
  export interface OutputObject {
    id: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace SequencerBatchDataEvent {
  export type InputTuple = [batchSequenceNumber: BigNumberish, data: BytesLike];
  export type OutputTuple = [batchSequenceNumber: bigint, data: string];
  export interface OutputObject {
    batchSequenceNumber: bigint;
    data: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace SequencerBatchDeliveredEvent {
  export type InputTuple = [
    batchSequenceNumber: BigNumberish,
    beforeAcc: BytesLike,
    afterAcc: BytesLike,
    delayedAcc: BytesLike,
    afterDelayedMessagesRead: BigNumberish,
    timeBounds: IBridge.TimeBoundsStruct,
    dataLocation: BigNumberish,
  ];
  export type OutputTuple = [
    batchSequenceNumber: bigint,
    beforeAcc: string,
    afterAcc: string,
    delayedAcc: string,
    afterDelayedMessagesRead: bigint,
    timeBounds: IBridge.TimeBoundsStructOutput,
    dataLocation: bigint,
  ];
  export interface OutputObject {
    batchSequenceNumber: bigint;
    beforeAcc: string;
    afterAcc: string;
    delayedAcc: string;
    afterDelayedMessagesRead: bigint;
    timeBounds: IBridge.TimeBoundsStructOutput;
    dataLocation: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace SequencerSetEvent {
  export type InputTuple = [addr: AddressLike, isSequencer: boolean];
  export type OutputTuple = [addr: string, isSequencer: boolean];
  export interface OutputObject {
    addr: string;
    isSequencer: boolean;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace SetValidKeysetEvent {
  export type InputTuple = [keysetHash: BytesLike, keysetBytes: BytesLike];
  export type OutputTuple = [keysetHash: string, keysetBytes: string];
  export interface OutputObject {
    keysetHash: string;
    keysetBytes: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export interface ISequencerInbox extends BaseContract {
  connect(runner?: ContractRunner | null): ISequencerInbox;
  waitForDeployment(): Promise<this>;

  interface: ISequencerInboxInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined,
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined,
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>,
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>,
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>,
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>,
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent,
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent,
  ): Promise<this>;

  BROTLI_MESSAGE_HEADER_FLAG: TypedContractMethod<[], [string], "view">;

  DAS_MESSAGE_HEADER_FLAG: TypedContractMethod<[], [string], "view">;

  DATA_AUTHENTICATED_FLAG: TypedContractMethod<[], [string], "view">;

  DATA_BLOB_HEADER_FLAG: TypedContractMethod<[], [string], "view">;

  HEADER_LENGTH: TypedContractMethod<[], [bigint], "view">;

  TREE_DAS_MESSAGE_HEADER_FLAG: TypedContractMethod<[], [string], "view">;

  ZERO_HEAVY_MESSAGE_HEADER_FLAG: TypedContractMethod<[], [string], "view">;

  addSequencerL2Batch: TypedContractMethod<
    [
      sequenceNumber: BigNumberish,
      data: BytesLike,
      afterDelayedMessagesRead: BigNumberish,
      gasRefunder: AddressLike,
      prevMessageCount: BigNumberish,
      newMessageCount: BigNumberish,
    ],
    [void],
    "nonpayable"
  >;

  addSequencerL2BatchDelayProof: TypedContractMethod<
    [
      sequenceNumber: BigNumberish,
      data: BytesLike,
      afterDelayedMessagesRead: BigNumberish,
      gasRefunder: AddressLike,
      prevMessageCount: BigNumberish,
      newMessageCount: BigNumberish,
      delayProof: DelayProofStruct,
    ],
    [void],
    "nonpayable"
  >;

  addSequencerL2BatchFromBlobs: TypedContractMethod<
    [
      sequenceNumber: BigNumberish,
      afterDelayedMessagesRead: BigNumberish,
      gasRefunder: AddressLike,
      prevMessageCount: BigNumberish,
      newMessageCount: BigNumberish,
    ],
    [void],
    "nonpayable"
  >;

  addSequencerL2BatchFromBlobsDelayProof: TypedContractMethod<
    [
      sequenceNumber: BigNumberish,
      afterDelayedMessagesRead: BigNumberish,
      gasRefunder: AddressLike,
      prevMessageCount: BigNumberish,
      newMessageCount: BigNumberish,
      delayProof: DelayProofStruct,
    ],
    [void],
    "nonpayable"
  >;

  "addSequencerL2BatchFromOrigin(uint256,bytes,uint256,address)": TypedContractMethod<
    [
      sequenceNumber: BigNumberish,
      data: BytesLike,
      afterDelayedMessagesRead: BigNumberish,
      gasRefunder: AddressLike,
    ],
    [void],
    "nonpayable"
  >;

  "addSequencerL2BatchFromOrigin(uint256,bytes,uint256,address,uint256,uint256)": TypedContractMethod<
    [
      sequenceNumber: BigNumberish,
      data: BytesLike,
      afterDelayedMessagesRead: BigNumberish,
      gasRefunder: AddressLike,
      prevMessageCount: BigNumberish,
      newMessageCount: BigNumberish,
    ],
    [void],
    "nonpayable"
  >;

  addSequencerL2BatchFromOriginDelayProof: TypedContractMethod<
    [
      sequenceNumber: BigNumberish,
      data: BytesLike,
      afterDelayedMessagesRead: BigNumberish,
      gasRefunder: AddressLike,
      prevMessageCount: BigNumberish,
      newMessageCount: BigNumberish,
      delayProof: DelayProofStruct,
    ],
    [void],
    "nonpayable"
  >;

  batchCount: TypedContractMethod<[], [bigint], "view">;

  batchPosterManager: TypedContractMethod<[], [string], "view">;

  bridge: TypedContractMethod<[], [string], "view">;

  dasKeySetInfo: TypedContractMethod<
    [arg0: BytesLike],
    [[boolean, bigint]],
    "view"
  >;

  feeTokenPricer: TypedContractMethod<[], [string], "view">;

  forceInclusion: TypedContractMethod<
    [
      _totalDelayedMessagesRead: BigNumberish,
      kind: BigNumberish,
      l1BlockAndTime: [BigNumberish, BigNumberish],
      baseFeeL1: BigNumberish,
      sender: AddressLike,
      messageDataHash: BytesLike,
    ],
    [void],
    "nonpayable"
  >;

  forceInclusionDeadline: TypedContractMethod<
    [blockNumber: BigNumberish],
    [bigint],
    "view"
  >;

  getKeysetCreationBlock: TypedContractMethod<
    [ksHash: BytesLike],
    [bigint],
    "view"
  >;

  inboxAccs: TypedContractMethod<[index: BigNumberish], [string], "view">;

  initialize: TypedContractMethod<
    [
      bridge_: AddressLike,
      maxTimeVariation_: ISequencerInbox.MaxTimeVariationStruct,
      bufferConfig_: BufferConfigStruct,
      feeTokenPricer_: AddressLike,
    ],
    [void],
    "nonpayable"
  >;

  invalidateKeysetHash: TypedContractMethod<
    [ksHash: BytesLike],
    [void],
    "nonpayable"
  >;

  isBatchPoster: TypedContractMethod<[arg0: AddressLike], [boolean], "view">;

  isDelayBufferable: TypedContractMethod<[], [boolean], "view">;

  isSequencer: TypedContractMethod<[arg0: AddressLike], [boolean], "view">;

  isValidKeysetHash: TypedContractMethod<
    [ksHash: BytesLike],
    [boolean],
    "view"
  >;

  maxDataSize: TypedContractMethod<[], [bigint], "view">;

  maxTimeVariation: TypedContractMethod<
    [],
    [
      [bigint, bigint, bigint, bigint] & {
        delayBlocks: bigint;
        futureBlocks: bigint;
        delaySeconds: bigint;
        futureSeconds: bigint;
      },
    ],
    "view"
  >;

  removeDelayAfterFork: TypedContractMethod<[], [void], "nonpayable">;

  rollup: TypedContractMethod<[], [string], "view">;

  setBatchPosterManager: TypedContractMethod<
    [newBatchPosterManager: AddressLike],
    [void],
    "nonpayable"
  >;

  setFeeTokenPricer: TypedContractMethod<
    [newFeeTokenPricer: AddressLike],
    [void],
    "nonpayable"
  >;

  setIsBatchPoster: TypedContractMethod<
    [addr: AddressLike, isBatchPoster_: boolean],
    [void],
    "nonpayable"
  >;

  setIsSequencer: TypedContractMethod<
    [addr: AddressLike, isSequencer_: boolean],
    [void],
    "nonpayable"
  >;

  setMaxTimeVariation: TypedContractMethod<
    [maxTimeVariation_: ISequencerInbox.MaxTimeVariationStruct],
    [void],
    "nonpayable"
  >;

  setValidKeyset: TypedContractMethod<
    [keysetBytes: BytesLike],
    [void],
    "nonpayable"
  >;

  totalDelayedMessagesRead: TypedContractMethod<[], [bigint], "view">;

  updateRollupAddress: TypedContractMethod<[], [void], "nonpayable">;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment,
  ): T;

  getFunction(
    nameOrSignature: "BROTLI_MESSAGE_HEADER_FLAG",
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "DAS_MESSAGE_HEADER_FLAG",
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "DATA_AUTHENTICATED_FLAG",
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "DATA_BLOB_HEADER_FLAG",
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "HEADER_LENGTH",
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "TREE_DAS_MESSAGE_HEADER_FLAG",
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "ZERO_HEAVY_MESSAGE_HEADER_FLAG",
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "addSequencerL2Batch",
  ): TypedContractMethod<
    [
      sequenceNumber: BigNumberish,
      data: BytesLike,
      afterDelayedMessagesRead: BigNumberish,
      gasRefunder: AddressLike,
      prevMessageCount: BigNumberish,
      newMessageCount: BigNumberish,
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "addSequencerL2BatchDelayProof",
  ): TypedContractMethod<
    [
      sequenceNumber: BigNumberish,
      data: BytesLike,
      afterDelayedMessagesRead: BigNumberish,
      gasRefunder: AddressLike,
      prevMessageCount: BigNumberish,
      newMessageCount: BigNumberish,
      delayProof: DelayProofStruct,
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "addSequencerL2BatchFromBlobs",
  ): TypedContractMethod<
    [
      sequenceNumber: BigNumberish,
      afterDelayedMessagesRead: BigNumberish,
      gasRefunder: AddressLike,
      prevMessageCount: BigNumberish,
      newMessageCount: BigNumberish,
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "addSequencerL2BatchFromBlobsDelayProof",
  ): TypedContractMethod<
    [
      sequenceNumber: BigNumberish,
      afterDelayedMessagesRead: BigNumberish,
      gasRefunder: AddressLike,
      prevMessageCount: BigNumberish,
      newMessageCount: BigNumberish,
      delayProof: DelayProofStruct,
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "addSequencerL2BatchFromOrigin(uint256,bytes,uint256,address)",
  ): TypedContractMethod<
    [
      sequenceNumber: BigNumberish,
      data: BytesLike,
      afterDelayedMessagesRead: BigNumberish,
      gasRefunder: AddressLike,
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "addSequencerL2BatchFromOrigin(uint256,bytes,uint256,address,uint256,uint256)",
  ): TypedContractMethod<
    [
      sequenceNumber: BigNumberish,
      data: BytesLike,
      afterDelayedMessagesRead: BigNumberish,
      gasRefunder: AddressLike,
      prevMessageCount: BigNumberish,
      newMessageCount: BigNumberish,
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "addSequencerL2BatchFromOriginDelayProof",
  ): TypedContractMethod<
    [
      sequenceNumber: BigNumberish,
      data: BytesLike,
      afterDelayedMessagesRead: BigNumberish,
      gasRefunder: AddressLike,
      prevMessageCount: BigNumberish,
      newMessageCount: BigNumberish,
      delayProof: DelayProofStruct,
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "batchCount",
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "batchPosterManager",
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "bridge",
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "dasKeySetInfo",
  ): TypedContractMethod<[arg0: BytesLike], [[boolean, bigint]], "view">;
  getFunction(
    nameOrSignature: "feeTokenPricer",
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "forceInclusion",
  ): TypedContractMethod<
    [
      _totalDelayedMessagesRead: BigNumberish,
      kind: BigNumberish,
      l1BlockAndTime: [BigNumberish, BigNumberish],
      baseFeeL1: BigNumberish,
      sender: AddressLike,
      messageDataHash: BytesLike,
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "forceInclusionDeadline",
  ): TypedContractMethod<[blockNumber: BigNumberish], [bigint], "view">;
  getFunction(
    nameOrSignature: "getKeysetCreationBlock",
  ): TypedContractMethod<[ksHash: BytesLike], [bigint], "view">;
  getFunction(
    nameOrSignature: "inboxAccs",
  ): TypedContractMethod<[index: BigNumberish], [string], "view">;
  getFunction(
    nameOrSignature: "initialize",
  ): TypedContractMethod<
    [
      bridge_: AddressLike,
      maxTimeVariation_: ISequencerInbox.MaxTimeVariationStruct,
      bufferConfig_: BufferConfigStruct,
      feeTokenPricer_: AddressLike,
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "invalidateKeysetHash",
  ): TypedContractMethod<[ksHash: BytesLike], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "isBatchPoster",
  ): TypedContractMethod<[arg0: AddressLike], [boolean], "view">;
  getFunction(
    nameOrSignature: "isDelayBufferable",
  ): TypedContractMethod<[], [boolean], "view">;
  getFunction(
    nameOrSignature: "isSequencer",
  ): TypedContractMethod<[arg0: AddressLike], [boolean], "view">;
  getFunction(
    nameOrSignature: "isValidKeysetHash",
  ): TypedContractMethod<[ksHash: BytesLike], [boolean], "view">;
  getFunction(
    nameOrSignature: "maxDataSize",
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "maxTimeVariation",
  ): TypedContractMethod<
    [],
    [
      [bigint, bigint, bigint, bigint] & {
        delayBlocks: bigint;
        futureBlocks: bigint;
        delaySeconds: bigint;
        futureSeconds: bigint;
      },
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "removeDelayAfterFork",
  ): TypedContractMethod<[], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "rollup",
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "setBatchPosterManager",
  ): TypedContractMethod<
    [newBatchPosterManager: AddressLike],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "setFeeTokenPricer",
  ): TypedContractMethod<
    [newFeeTokenPricer: AddressLike],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "setIsBatchPoster",
  ): TypedContractMethod<
    [addr: AddressLike, isBatchPoster_: boolean],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "setIsSequencer",
  ): TypedContractMethod<
    [addr: AddressLike, isSequencer_: boolean],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "setMaxTimeVariation",
  ): TypedContractMethod<
    [maxTimeVariation_: ISequencerInbox.MaxTimeVariationStruct],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "setValidKeyset",
  ): TypedContractMethod<[keysetBytes: BytesLike], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "totalDelayedMessagesRead",
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "updateRollupAddress",
  ): TypedContractMethod<[], [void], "nonpayable">;

  getEvent(
    key: "BatchPosterManagerSet",
  ): TypedContractEvent<
    BatchPosterManagerSetEvent.InputTuple,
    BatchPosterManagerSetEvent.OutputTuple,
    BatchPosterManagerSetEvent.OutputObject
  >;
  getEvent(
    key: "BatchPosterSet",
  ): TypedContractEvent<
    BatchPosterSetEvent.InputTuple,
    BatchPosterSetEvent.OutputTuple,
    BatchPosterSetEvent.OutputObject
  >;
  getEvent(
    key: "BufferConfigSet",
  ): TypedContractEvent<
    BufferConfigSetEvent.InputTuple,
    BufferConfigSetEvent.OutputTuple,
    BufferConfigSetEvent.OutputObject
  >;
  getEvent(
    key: "FeeTokenPricerSet",
  ): TypedContractEvent<
    FeeTokenPricerSetEvent.InputTuple,
    FeeTokenPricerSetEvent.OutputTuple,
    FeeTokenPricerSetEvent.OutputObject
  >;
  getEvent(
    key: "InboxMessageDelivered",
  ): TypedContractEvent<
    InboxMessageDeliveredEvent.InputTuple,
    InboxMessageDeliveredEvent.OutputTuple,
    InboxMessageDeliveredEvent.OutputObject
  >;
  getEvent(
    key: "InboxMessageDeliveredFromOrigin",
  ): TypedContractEvent<
    InboxMessageDeliveredFromOriginEvent.InputTuple,
    InboxMessageDeliveredFromOriginEvent.OutputTuple,
    InboxMessageDeliveredFromOriginEvent.OutputObject
  >;
  getEvent(
    key: "InvalidateKeyset",
  ): TypedContractEvent<
    InvalidateKeysetEvent.InputTuple,
    InvalidateKeysetEvent.OutputTuple,
    InvalidateKeysetEvent.OutputObject
  >;
  getEvent(
    key: "MaxTimeVariationSet",
  ): TypedContractEvent<
    MaxTimeVariationSetEvent.InputTuple,
    MaxTimeVariationSetEvent.OutputTuple,
    MaxTimeVariationSetEvent.OutputObject
  >;
  getEvent(
    key: "OwnerFunctionCalled",
  ): TypedContractEvent<
    OwnerFunctionCalledEvent.InputTuple,
    OwnerFunctionCalledEvent.OutputTuple,
    OwnerFunctionCalledEvent.OutputObject
  >;
  getEvent(
    key: "SequencerBatchData",
  ): TypedContractEvent<
    SequencerBatchDataEvent.InputTuple,
    SequencerBatchDataEvent.OutputTuple,
    SequencerBatchDataEvent.OutputObject
  >;
  getEvent(
    key: "SequencerBatchDelivered",
  ): TypedContractEvent<
    SequencerBatchDeliveredEvent.InputTuple,
    SequencerBatchDeliveredEvent.OutputTuple,
    SequencerBatchDeliveredEvent.OutputObject
  >;
  getEvent(
    key: "SequencerSet",
  ): TypedContractEvent<
    SequencerSetEvent.InputTuple,
    SequencerSetEvent.OutputTuple,
    SequencerSetEvent.OutputObject
  >;
  getEvent(
    key: "SetValidKeyset",
  ): TypedContractEvent<
    SetValidKeysetEvent.InputTuple,
    SetValidKeysetEvent.OutputTuple,
    SetValidKeysetEvent.OutputObject
  >;

  filters: {
    "BatchPosterManagerSet(address)": TypedContractEvent<
      BatchPosterManagerSetEvent.InputTuple,
      BatchPosterManagerSetEvent.OutputTuple,
      BatchPosterManagerSetEvent.OutputObject
    >;
    BatchPosterManagerSet: TypedContractEvent<
      BatchPosterManagerSetEvent.InputTuple,
      BatchPosterManagerSetEvent.OutputTuple,
      BatchPosterManagerSetEvent.OutputObject
    >;

    "BatchPosterSet(address,bool)": TypedContractEvent<
      BatchPosterSetEvent.InputTuple,
      BatchPosterSetEvent.OutputTuple,
      BatchPosterSetEvent.OutputObject
    >;
    BatchPosterSet: TypedContractEvent<
      BatchPosterSetEvent.InputTuple,
      BatchPosterSetEvent.OutputTuple,
      BatchPosterSetEvent.OutputObject
    >;

    "BufferConfigSet(tuple)": TypedContractEvent<
      BufferConfigSetEvent.InputTuple,
      BufferConfigSetEvent.OutputTuple,
      BufferConfigSetEvent.OutputObject
    >;
    BufferConfigSet: TypedContractEvent<
      BufferConfigSetEvent.InputTuple,
      BufferConfigSetEvent.OutputTuple,
      BufferConfigSetEvent.OutputObject
    >;

    "FeeTokenPricerSet(address)": TypedContractEvent<
      FeeTokenPricerSetEvent.InputTuple,
      FeeTokenPricerSetEvent.OutputTuple,
      FeeTokenPricerSetEvent.OutputObject
    >;
    FeeTokenPricerSet: TypedContractEvent<
      FeeTokenPricerSetEvent.InputTuple,
      FeeTokenPricerSetEvent.OutputTuple,
      FeeTokenPricerSetEvent.OutputObject
    >;

    "InboxMessageDelivered(uint256,bytes)": TypedContractEvent<
      InboxMessageDeliveredEvent.InputTuple,
      InboxMessageDeliveredEvent.OutputTuple,
      InboxMessageDeliveredEvent.OutputObject
    >;
    InboxMessageDelivered: TypedContractEvent<
      InboxMessageDeliveredEvent.InputTuple,
      InboxMessageDeliveredEvent.OutputTuple,
      InboxMessageDeliveredEvent.OutputObject
    >;

    "InboxMessageDeliveredFromOrigin(uint256)": TypedContractEvent<
      InboxMessageDeliveredFromOriginEvent.InputTuple,
      InboxMessageDeliveredFromOriginEvent.OutputTuple,
      InboxMessageDeliveredFromOriginEvent.OutputObject
    >;
    InboxMessageDeliveredFromOrigin: TypedContractEvent<
      InboxMessageDeliveredFromOriginEvent.InputTuple,
      InboxMessageDeliveredFromOriginEvent.OutputTuple,
      InboxMessageDeliveredFromOriginEvent.OutputObject
    >;

    "InvalidateKeyset(bytes32)": TypedContractEvent<
      InvalidateKeysetEvent.InputTuple,
      InvalidateKeysetEvent.OutputTuple,
      InvalidateKeysetEvent.OutputObject
    >;
    InvalidateKeyset: TypedContractEvent<
      InvalidateKeysetEvent.InputTuple,
      InvalidateKeysetEvent.OutputTuple,
      InvalidateKeysetEvent.OutputObject
    >;

    "MaxTimeVariationSet(tuple)": TypedContractEvent<
      MaxTimeVariationSetEvent.InputTuple,
      MaxTimeVariationSetEvent.OutputTuple,
      MaxTimeVariationSetEvent.OutputObject
    >;
    MaxTimeVariationSet: TypedContractEvent<
      MaxTimeVariationSetEvent.InputTuple,
      MaxTimeVariationSetEvent.OutputTuple,
      MaxTimeVariationSetEvent.OutputObject
    >;

    "OwnerFunctionCalled(uint256)": TypedContractEvent<
      OwnerFunctionCalledEvent.InputTuple,
      OwnerFunctionCalledEvent.OutputTuple,
      OwnerFunctionCalledEvent.OutputObject
    >;
    OwnerFunctionCalled: TypedContractEvent<
      OwnerFunctionCalledEvent.InputTuple,
      OwnerFunctionCalledEvent.OutputTuple,
      OwnerFunctionCalledEvent.OutputObject
    >;

    "SequencerBatchData(uint256,bytes)": TypedContractEvent<
      SequencerBatchDataEvent.InputTuple,
      SequencerBatchDataEvent.OutputTuple,
      SequencerBatchDataEvent.OutputObject
    >;
    SequencerBatchData: TypedContractEvent<
      SequencerBatchDataEvent.InputTuple,
      SequencerBatchDataEvent.OutputTuple,
      SequencerBatchDataEvent.OutputObject
    >;

    "SequencerBatchDelivered(uint256,bytes32,bytes32,bytes32,uint256,tuple,uint8)": TypedContractEvent<
      SequencerBatchDeliveredEvent.InputTuple,
      SequencerBatchDeliveredEvent.OutputTuple,
      SequencerBatchDeliveredEvent.OutputObject
    >;
    SequencerBatchDelivered: TypedContractEvent<
      SequencerBatchDeliveredEvent.InputTuple,
      SequencerBatchDeliveredEvent.OutputTuple,
      SequencerBatchDeliveredEvent.OutputObject
    >;

    "SequencerSet(address,bool)": TypedContractEvent<
      SequencerSetEvent.InputTuple,
      SequencerSetEvent.OutputTuple,
      SequencerSetEvent.OutputObject
    >;
    SequencerSet: TypedContractEvent<
      SequencerSetEvent.InputTuple,
      SequencerSetEvent.OutputTuple,
      SequencerSetEvent.OutputObject
    >;

    "SetValidKeyset(bytes32,bytes)": TypedContractEvent<
      SetValidKeysetEvent.InputTuple,
      SetValidKeysetEvent.OutputTuple,
      SetValidKeysetEvent.OutputObject
    >;
    SetValidKeyset: TypedContractEvent<
      SetValidKeysetEvent.InputTuple,
      SetValidKeysetEvent.OutputTuple,
      SetValidKeysetEvent.OutputObject
    >;
  };
}
